import { partial, concat, bitLength, clamp } from './bitarray';
export function hash(str) {
    return fromBits(new SHA256().update(str).finalize());
}
export function hmac(key, data) {
    var k = [];
    var d = [];
    if (typeof key === 'string') {
        k = toHexBits(key);
    }
    else {
        k = key;
    }
    if (typeof data === 'string') {
        d = toHexBits(data);
    }
    else {
        d = data;
    }
    var k1 = [];
    var h1 = new SHA256();
    var k2 = [];
    var h2 = new SHA256();
    var bs = 16; // blocksize: 512 / 32
    if (k.length > bs) {
        k = new SHA256().update(k).finalize();
    }
    for (var i = 0; i < bs; i++) {
        k1[i] = k[i] ^ 0x36363636;
        k2[i] = k[i] ^ 0x5c5c5c5c;
    }
    var w = h1
        .update(k1)
        .update(d)
        .finalize();
    return fromBits(h2
        .update(k2)
        .update(w)
        .finalize());
}
var SHA256 = /** @class */ (function () {
    function SHA256(hash) {
        this.key = [];
        this.init = [];
        if (!this.key[0])
            this.precompute();
        if (hash) {
            this.h = hash.h;
            this.buffer = hash.buffer.slice(0);
            this.length = hash.length;
        }
        else {
            this.reset();
        }
    }
    SHA256.prototype.reset = function () {
        this.h = this.init.slice(0);
        this.buffer = [];
        this.length = 0;
        return this;
    };
    SHA256.prototype.update = function (data) {
        if (typeof data === 'string') {
            data = toBits(data);
        }
        var i, b = (this.buffer = concat(this.buffer, data)), ol = this.length, nl = (this.length = ol + bitLength(data));
        if (nl > 9007199254740991) {
            throw new Error('Cannot hash more than 2^53 - 1 bits');
        }
        if (typeof Uint32Array !== 'undefined') {
            var c = new Uint32Array(b);
            var j = 0;
            for (i = 512 + ol - ((512 + ol) & 511); i <= nl; i += 512) {
                this.block(c.subarray(16 * j, 16 * (j + 1)));
                j += 1;
            }
            b.splice(0, 16 * j);
        }
        else {
            for (i = 512 + ol - ((512 + ol) & 511); i <= nl; i += 512) {
                this.block(b.splice(0, 16));
            }
        }
        return this;
    };
    SHA256.prototype.finalize = function () {
        var i, b = this.buffer, h = this.h;
        // Round out and push the buffer
        b = concat(b, [partial(1, 1)]);
        // Round out the buffer to a multiple of 16 words, less the 2 length words.
        for (i = b.length + 2; i & 15; i++) {
            b.push(0);
        }
        // append the length
        b.push(Math.floor(this.length / 0x100000000));
        b.push(this.length | 0);
        while (b.length) {
            this.block(b.splice(0, 16));
        }
        this.reset();
        return h;
    };
    SHA256.prototype.precompute = function () {
        var i = 0, prime = 2, factor, isPrime;
        function frac(x) {
            return ((x - Math.floor(x)) * 0x100000000) | 0;
        }
        for (; i < 64; prime++) {
            isPrime = true;
            for (factor = 2; factor * factor <= prime; factor++) {
                if (prime % factor === 0) {
                    isPrime = false;
                    break;
                }
            }
            if (isPrime) {
                if (i < 8) {
                    this.init[i] = frac(Math.pow(prime, 1 / 2));
                }
                this.key[i] = frac(Math.pow(prime, 1 / 3));
                i++;
            }
        }
    };
    /**
   * Perform one cycle of SHA-256.
   * @param {Uint32Array|bitArray} w one block of words.
   * @private
   */
    SHA256.prototype.block = function (w) {
        var i, tmp, a, b, h = this.h, k = this.key, h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3], h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];
        /* Rationale for placement of |0 :
         * If a value can overflow is original 32 bits by a factor of more than a few
         * million (2^23 ish), there is a possibility that it might overflow the
         * 53-bit mantissa and lose precision.
         *
         * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that
         * propagates around the loop, and on the hash state h[].  I don't believe
         * that the clamps on h4 and on h0 are strictly necessary, but it's close
         * (for h4 anyway), and better safe than sorry.
         *
         * The clamps on h[] are necessary for the output to be correct even in the
         * common case and for short inputs.
         */
        for (i = 0; i < 64; i++) {
            // load up the input word for this round
            if (i < 16) {
                tmp = w[i];
            }
            else {
                a = w[(i + 1) & 15];
                b = w[(i + 14) & 15];
                tmp = w[i & 15] =
                    (((a >>> 7) ^ (a >>> 18) ^ (a >>> 3) ^ (a << 25) ^ (a << 14)) +
                        ((b >>> 17) ^ (b >>> 19) ^ (b >>> 10) ^ (b << 15) ^ (b << 13)) +
                        w[i & 15] +
                        w[(i + 9) & 15]) |
                        0;
            }
            tmp =
                tmp +
                    h7 +
                    ((h4 >>> 6) ^
                        (h4 >>> 11) ^
                        (h4 >>> 25) ^
                        (h4 << 26) ^
                        (h4 << 21) ^
                        (h4 << 7)) +
                    (h6 ^ (h4 & (h5 ^ h6))) +
                    k[i]; // | 0;
            // shift register
            h7 = h6;
            h6 = h5;
            h5 = h4;
            h4 = (h3 + tmp) | 0;
            h3 = h2;
            h2 = h1;
            h1 = h0;
            h0 =
                (tmp +
                    ((h1 & h2) ^ (h3 & (h1 ^ h2))) +
                    ((h1 >>> 2) ^
                        (h1 >>> 13) ^
                        (h1 >>> 22) ^
                        (h1 << 30) ^
                        (h1 << 19) ^
                        (h1 << 10))) |
                    0;
        }
        h[0] = (h[0] + h0) | 0;
        h[1] = (h[1] + h1) | 0;
        h[2] = (h[2] + h2) | 0;
        h[3] = (h[3] + h3) | 0;
        h[4] = (h[4] + h4) | 0;
        h[5] = (h[5] + h5) | 0;
        h[6] = (h[6] + h6) | 0;
        h[7] = (h[7] + h7) | 0;
    };
    return SHA256;
}());
export { SHA256 };
function toBits(str) {
    str = decodeURI(encodeURIComponent(str));
    var out = [], i, tmp = 0;
    for (i = 0; i < str.length; i++) {
        tmp = (tmp << 8) | str.charCodeAt(i);
        if ((i & 3) === 3) {
            out.push(tmp);
            tmp = 0;
        }
    }
    if (i & 3) {
        out.push(partial(8 * (i & 3), tmp));
    }
    return out;
}
function toHexBits(str) {
    var i, out = [], len;
    str = str.replace(/\s|0x/g, '');
    len = str.length;
    str = str + '00000000';
    for (i = 0; i < str.length; i += 8) {
        out.push(parseInt(str.substr(i, 8), 16) ^ 0);
    }
    return clamp(out, len * 4);
}
function fromBits(arr) {
    var out = '', i;
    for (i = 0; i < arr.length; i++) {
        out += ((arr[i] | 0) + 0xf00000000000).toString(16).substr(4);
    }
    return out.substr(0, bitLength(arr) / 4); //.replace(/(.{8})/g, "$1 ");
}
//# sourceMappingURL=index.js.map